name: Backfill recorded series (Prometheus)

on:
  workflow_dispatch:
    inputs:
      window_hours:
        description: "If start is empty, backfill this many hours ending now (UTC)"
        required: false
        default: "24"
        type: number
      start:
        description: "ISO8601 UTC start (e.g., 2025-08-01T00:00:00Z)"
        required: false
        type: string
      end:
        description: "ISO8601 UTC end (default now, if start set and end omitted)"
        required: false
        type: string
      step:
        description: "Evaluation step for promtool create-blocks-from"
        required: false
        default: "30s"
        type: string
      ns:
        description: "Namespace where Prometheus runs"
        required: false
        default: "monitoring"
        type: string
      release:
        description: "Helm release (kube-prometheus-stack) to narrow detection"
        required: false
        default: ""
        type: string
      prom_url:
        description: "Override Prometheus query URL (else Makefile default)"
        required: false
        default: ""
        type: string
      keep_job:
        description: "Keep the K8s backfill Job for inspection"
        required: false
        default: false
        type: boolean
      no_scale:
        description: "Do NOT scale the Prometheus STS (advanced)"
        required: false
        default: false
        type: boolean
      dry_run:
        description: "Detect and cache only; do not run backfill"
        required: false
        default: false
        type: boolean

concurrency:
  group: backfill-${{ github.ref }}-${{ inputs.ns || 'monitoring' }}
  cancel-in-progress: false

permissions:
  contents: read

env:
  BACKFILL_MAX_HOURS: "168"   # guardrail to prevent large/expensive backfills

jobs:
  backfill:
    name: Detect → Cache → Backfill
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure kubectl from secret KUBECONFIG_DATA
        shell: bash
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
        run: |
          set -euo pipefail
          mkdir -p ~/.kube
          if [ -z "${KUBECONFIG_DATA:-}" ]; then
            echo "ERROR: secrets.KUBECONFIG_DATA is not set" >&2
            exit 1
          fi
          # Try base64 decode first; if it fails assume plain YAML
          if echo "$KUBECONFIG_DATA" | base64 -d >/dev/null 2>&1; then
            echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
          else
            printf "%s" "$KUBECONFIG_DATA" > ~/.kube/config
          fi
          chmod 600 ~/.kube/config
          kubectl version --client

      - name: Compute backfill window
        id: window
        shell: bash
        env:
          INPUT_START: ${{ inputs.start }}
          INPUT_END: ${{ inputs.end }}
          INPUT_WINDOW_HOURS: ${{ inputs.window_hours }}
          MAX_HOURS: ${{ env.BACKFILL_MAX_HOURS }}
        run: |
          set -euo pipefail
          start="${INPUT_START:-}"
          end="${INPUT_END:-}"
          window_hours="${INPUT_WINDOW_HOURS:-24}"
          now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          if [ -z "$start" ]; then
            # default: last window_hours hours ending now
            end="$now"
            start="$(date -u -d "$end - ${window_hours} hours" +%Y-%m-%dT%H:%M:%SZ)"
          elif [ -z "$end" ]; then
            end="$now"
          fi
          # guardrail: enforce max window
          start_s=$(date -u -d "$start" +%s)
          end_s=$(date -u -d "$end" +%s)
          if [ "$end_s" -le "$start_s" ]; then
            echo "ERROR: end <= start ($start .. $end)" >&2; exit 1
          fi
          hours=$(( (end_s - start_s) / 3600 ))
          if [ "$hours" -gt "$MAX_HOURS" ]; then
            echo "ERROR: requested window ${hours}h exceeds BACKFILL_MAX_HOURS=${MAX_HOURS}" >&2
            exit 1
          fi
          echo "start=$start" | tee -a backfill_window.env
          echo "end=$end"     | tee -a backfill_window.env
          {
            echo "start=$start"
            echo "end=$end"
          } >> "$GITHUB_OUTPUT"

      - name: Detect Prometheus STS/PVC
        id: detect
        shell: bash
        env:
          NS: ${{ inputs.ns }}
          RELEASE: ${{ inputs.release }}
        run: |
          set -euo pipefail
          echo "Detecting with NS=${NS:-monitoring} RELEASE=${RELEASE:-''}"
          make -f Makefile.backfill.mk detect-prom-vars NS="${NS:-monitoring}" RELEASE="${RELEASE:-}"
          make -f Makefile.backfill.mk detect-prom-vars NS="${NS:-monitoring}" RELEASE="${RELEASE:-}" > backfill_vars.env
          cat backfill_vars.env
          # Export into outputs
          PROM_STS="$(grep '^PROM_STS=' backfill_vars.env | cut -d'=' -f2-)"
          PROM_PVC="$(grep '^PROM_PVC=' backfill_vars.env | cut -d'=' -f2-)"
          if [ -z "$PROM_STS" ] || [ -z "$PROM_PVC" ]; then
            echo "ERROR: could not parse PROM_STS/PROM_PVC" >&2; exit 1
          fi
          echo "PROM_STS=$PROM_STS" >> "$GITHUB_OUTPUT"
          echo "PROM_PVC=$PROM_PVC" >> "$GITHUB_OUTPUT"

      - name: Cache detection outputs
        uses: actions/cache@v4
        with:
          path: .cache/backfill
          key: backfill-detect-${{ github.ref }}-${{ inputs.ns }}-${{ inputs.release }}-${{ github.run_id }}

      - name: Store detection and window files
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .cache/backfill
          cp -f backfill_vars.env .cache/backfill/
          cp -f backfill_window.env .cache/backfill/

      - name: Upload detection artifact
        uses: actions/upload-artifact@v4
        with:
          name: backfill-detect-${{ github.run_id }}
          path: |
            backfill_vars.env
            backfill_window.env

      - name: (Dry run) Stop here
        if: ${{ inputs.dry_run == true }}
        run: echo "Dry run enabled. Skipping backfill job."

      - name: Run backfill job (auto-detected STS/PVC)
        if: ${{ inputs.dry_run != true }}
        shell: bash
        env:
          START: ${{ steps.window.outputs.start }}
          END:   ${{ steps.window.outputs.end }}
          STEP:  ${{ inputs.step }}
          NS:    ${{ inputs.ns }}
          RELEASE: ${{ inputs.release }}
          PROM_URL: ${{ inputs.prom_url }}
          KEEP_BOOL: ${{ inputs.keep_job }}
          NOSCALE_BOOL: ${{ inputs.no_scale }}
        run: |
          set -euo pipefail
          KEEP=0; [ "${KEEP_BOOL}" = "true" ] && KEEP=1 || true
          NOSCALE=0; [ "${NOSCALE_BOOL}" = "true" ] && NOSCALE=1 || true
          # PROM_URL may be empty -> Makefile default will be used
          make -f Makefile.backfill.mk backfill-rules-auto \
            BACKFILL_START="${START}" \
            BACKFILL_END="${END}" \
            BACKFILL_STEP="${STEP}" \
            NS="${NS:-monitoring}" \
            RELEASE="${RELEASE:-}" \
            KEEP_JOB="${KEEP}" \
            NO_SCALE="${NOSCALE}" \
            PROM_QUERY_URL="${PROM_URL}"

